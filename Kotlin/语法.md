[TOC]

## 动态改变shape的背景色

```
    GradientDrawable mGradientDrawable = (GradientDrawable)tv.getBackground();
    mGradientDrawable .setColor(getResources().getColor(R.color.colorPrimaryDark));
//或者
   mGradientDrawable .setColor(Color.parseColor("#EEEEEE"));
```
## 类的构造方法

```
class Bird(

    weight: Double = 0.00, // 参数名前没有val
    age: Int = 0,
    color: String = "blue") {

val weight: Double
val age: Int
val color: String

    init {
        this.weight = weight // 构造方法参数可以在init语句块被调用
        this.age = age
        this.color = color
    }
}
```

```
class Bird(weight: Double, age: Int, color: String) {

    init {
        println("do some other things")
        println("the weight is ${weight}")
    }
}
```

## 中缀函数

```
private fun callInfix() {
        val p = Person()
        p called "中缀方法执行"
        p.called("正常调用")
        "北京" add "上海"
    }
    private infix fun String.add(str:String):String{
        return str+this
    }
    
    // 中缀函数
class Person{
    //中缀方法必须是类的成员方法，有且只有一个不变参数，用infix修饰
    infix fun called(name: String?){
        Log.e("TAG", "called: 调用中缀方法：$name" )
    }
}
```
## by lazy 和 lateinit
- [x] by lazy用来修饰val声明的变量
- 该变量必须是引用不可变的，而不能通过var来声明。
- 在被首次调用时，才会进行赋值操作。一旦被赋值，后续它将不能被更改。
- 系统会给lazy属性默认加上同步锁，是线程安全的。

```
val sex: String by lazy {
    if (color == "yellow") "male" else "female"
}
```
- [x] lateinit主要用于var声明的变量

```
lateinit var sex: String // sex 可以延迟初始化
```
## 里氏替换原则
1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；
2. 子类可以增加自己特有的方法
3. 当子类的方法实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松；
4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

## 委托代替多继承

```
//接口委托
interface CanFly{
    fun fly()
}
interface CanEat{
    fun eat()
}

open class Flyer :CanFly {
    override fun fly() {
        Log.e("TAG", "fly: 执行" )
    }
}
open class Animal : CanEat {
    override fun eat() {
        Log.e("TAG", "eat: 执行" )
    }
}

//委托代替多继承
class Bird(flyer: Flyer, animal: Animal) :CanFly by flyer,CanEat by animal{

}

--------------调用---------------
// 委托代替多继承校验
       val flyer = Flyer()
       val animal = Animal()
       var b = Bird(flyer,animal)
        b.fly()
        b.eat()
```

## companion object伴生对象
- [x] 伴生对象是Kotlin中用来代替static关键字的一种方式，任何在Java类内部用static定义的内容都可以用Kotlin中的伴生对象来实现。然而，它们是类似的，一个类的伴生对象跟一个静态类一样，全局只能有一个，是单例模式

```
//伴生对象 实现工厂方法模式
class Prize constructor(val name: String, val count: Int, val type: Int){
    companion object{
        val TYPE_COMMON = 1
        val TYPE_REDPACK = 2
        val TYPE_COUPON = 3
        val defaultCommonPrize = Prize("普通奖品", 10, Prize.TYPE_COMMON)

        fun newRedpackPrize(name: String,count: Int) = Prize(name,count, TYPE_REDPACK)
        fun newCouponPrize(name: String,count: Int) = Prize(name,count, TYPE_COUPON)
        fun defaultCommonPrize() = defaultCommonPrize
    }
}
----------调用-------------------
 // 伴生对象创建工厂方法模式
        val redpackPrize = Prize.newRedpackPrize("红包", 10)
        val couponPrize = Prize.newCouponPrize("十元代金券", 10)
        val commonPrize = Prize.defaultCommonPrize()
        
```



