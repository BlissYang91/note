[TOC]
## 使用的依赖版本
- 同时启用databinding
- github地址： https://github.com/BlissYang91/kotlin


```
 dataBinding {
        enabled true
    }
    
    
 implementation 'androidx.core:core-ktx:1.1.0'
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.1"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.1"
    implementation "androidx.lifecycle:lifecycle-extensions:2.1.0"
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0"
    implementation "com.squareup.okhttp3:okhttp:4.2.0"
    implementation "com.squareup.retrofit2:retrofit:2.6.1"
    implementation "com.squareup.okhttp3:logging-interceptor:4.2.0"
    implementation "com.squareup.retrofit2:converter-gson:2.6.1"
```


- [x] 创建view model
- 现用方式
```
//      创建view model
        netViewModel = ViewModelProvider(this).get(NetViewMoudle::class.java)
```
- 废弃过时方式 ViewModelProviders is desprecated

```
//        netViewModel = ViewModelProviders.of(this).get(NetViewMoudle::class.java)

```

## retrofit封装类

```
package com.wjx.android.wanandroidmvvm.base.https

import android.util.Log
import com.example.myapp.common.Constant
import com.example.myapp.common.SPreference
import com.google.gson.Gson
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory
import retrofit2.converter.gson.GsonConverterFactory
import java.lang.StringBuilder
import java.util.concurrent.TimeUnit

/**
 * @Author yangtianfu
 * @CreateTime 2020/4/1 21:17
 * @Describe  retrofit封装类
 */
class RetrofitFactory private constructor() {
    private val retrofit: Retrofit


    init {

        val gson = Gson().newBuilder()
            .setLenient()
            .serializeNulls()
            .create()

        retrofit = Retrofit.Builder()
            .baseUrl("https://www.wanandroid.com/")
            .client(initOkhttpClient())
            .addConverterFactory(GsonConverterFactory.create(gson))
            .build()

    }


    companion object {
        val instance: RetrofitFactory by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {
            RetrofitFactory()
        }

    }


    private fun initOkhttpClient(): OkHttpClient {

        val okHttpClient = OkHttpClient.Builder()
            .connectTimeout(5, TimeUnit.SECONDS)
            .readTimeout(5, TimeUnit.SECONDS)
            .addInterceptor(initLogInterceptor())
            .build()


        return okHttpClient
    }


    /*
    * 日志拦截器
    * */
    private fun initLogInterceptor(): HttpLoggingInterceptor {

        val interceptor = HttpLoggingInterceptor(object : HttpLoggingInterceptor.Logger {
            override fun log(message: String) {
                Log.i("Retrofit", message)
            }
        })

        interceptor.level = HttpLoggingInterceptor.Level.BODY

        return interceptor
    }


    /*
    * 具体服务实例化
    * */
    fun <T> getService(service: Class<T>): T {

        return retrofit.create(service)
    }
}
```
## 网络相关数据结构
- [x] 返回数据最外层包装

```
package com.example.myapp.bean

/**
 * @Author yangtianfu
 * @CreateTime 2020/4/1 18:08
 * @Describe 返回数据最外层包装
 */


data class BaseResp<T> (
    var errorCode: Int = 0,
    var errorMsg: String = "",
    var data: T
)
```
- [x] 单个数据结构

```
package com.example.myapp.bean

/**
 * @Author yangtianfu
 * @CreateTime 2020/4/1 18:13
 * @Describe 单个数据返回实体类
 */
data class WBean(
    val apkLink: String,
    val audit: Int,
    val author: String,
    val canEdit: Boolean,
    val chapterId: Int,
    val chapterName: String,
    val collect: Boolean,
    val courseId: Int,
    val desc: String,
    val descMd: String,
    val envelopePic: String,
    val fresh: Boolean,
    val id: Int,
    val link: String,
    val niceDate: String,
    val niceShareDate: String,
    val origin: String,
    val prefix: String,
    val projectLink: String,
    val publishTime: Long,
    val selfVisible: Int,
    val shareDate: Long,
    val shareUser: String,
    val superChapterId: Int,
    val superChapterName: String,
    val tags: List<Any>,
    val title: String,
    val type: Int,
    val userId: Int,
    val visible: Int,
    val zan: Int
)
```
- [x] 数据顶层声明文件，全局的方法

```
package com.example.myapp.ext

import com.example.myapp.bean.BaseResp

/**
 * @Author yangtianfu
 * @CreateTime 2020/4/1 19:59
 * @Describe  数据解析扩展函数 顶层声明 作用域为package
 */

fun <T> BaseResp<T>.dataConvert(): T {
    if (errorCode == 0) {
        return data
    } else {
        throw Exception(errorMsg)
    }
}
```
## 定义协程api

```
package com.wjx.android.wanandroidmvvm.base.https

import com.example.myapp.bean.BaseResp
import com.example.myapp.bean.WBean
import retrofit2.http.GET

/**
 * @Author yangtianfu
 * @CreateTime 2020/3/31 21:04
 * @Describe retrofit 使用协程定义api
 */

interface ApiService {

    /**
     * 使用协程进行网络请求
     */
    @GET("article/top/json/")
    suspend fun getTopArticle(): BaseResp<List<WBean>>

}
```


## ViewModel层


```
package com.example.myapp.moudle

import android.util.Log
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.myapp.bean.WBean
import com.example.myapp.ext.dataConvert
import com.wjx.android.wanandroidmvvm.base.https.ApiService
import com.wjx.android.wanandroidmvvm.base.https.RetrofitFactory
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.lang.Exception
import kotlin.math.log

/**
 * @Author yangtianfu
 * @CreateTime 2020/4/1 19:18
 * @Describe 自带生命周期的viewmoudle
 */
class NetViewMoudle :ViewModel() {
//   vm持有数据层引用，并利用livedata赋值更新UI
    var list= MutableLiveData<List<WBean>>()

    /**
     * viewModelScope是一个绑定到当前viewModel的作用域  当ViewModel被清除时会自动取消该作用域，所以不用担心内存泄漏为问题
     */
    fun getTopArticle(){
        viewModelScope.launch {
            try {
                //withContext表示挂起块  配合Retrofit声明的suspend函数执行 该块会挂起直到里面的网络请求完成 最后一行就是返回值
                val data = withContext(Dispatchers.IO){
                    //dataConvert扩展函数可以很方便的解析出我们想要的数据  接口很多的情况下下可以节省不少无用代码
                    RetrofitFactory.instance.getService(ApiService::class.java).getTopArticle().dataConvert()
                }
                //给LiveData赋值  ui会自动更新
                list.value = data
            }catch (e:Exception){
                e.printStackTrace()
                Log.e("net error","网络请求错误${e.toString()}")
            }
        }
    }
}
```

## UI层调用

```
package com.example.myapp.ui

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.View
import androidx.databinding.DataBindingUtil
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.ViewModelProviders
import com.example.myapp.R
import com.example.myapp.bean.Animal
import com.example.myapp.databinding.ActivityMainBinding
import com.example.myapp.moudle.NetViewMoudle
import com.example.myapp.vm.AnimalViewModel
import com.google.gson.Gson
import com.wjx.android.wanandroidmvvm.base.https.ApiService
import com.wjx.android.wanandroidmvvm.base.https.RetrofitFactory
import kotlinx.android.synthetic.main.activity_main.*
import kotlin.jvm.java as java

class MainActivity : AppCompatActivity() {
    lateinit var mBinding:ActivityMainBinding
    lateinit var mViewMode:AnimalViewModel

    lateinit var netViewModel:NetViewMoudle
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mBinding = DataBindingUtil.setContentView<ActivityMainBinding>(this,R.layout.activity_main)
        var animal = Animal("dog",0)
        mViewMode = AnimalViewModel(animal)
        mBinding.model = mViewMode //model指代xml xml中 name="model"的VM对象

//      创建view model
//        netViewModel = ViewModelProviders.of(this).get(NetViewMoudle::class.java)
        netViewModel = ViewModelProvider(this).get(NetViewMoudle::class.java)

//        请求网络
        mBinding.listener = View.OnClickListener {
            when(it.id){
                R.id.btn ->  netViewModel.getTopArticle()
            }
        }
//        数据变化更新UI,livedata的数据被观察
        netViewModel.list.observe(this, Observer {
            tv.text = Gson().toJson(it)
        })

    }


}

```

##  日志拦截器

```
import com.aquila.lib.KLog
import okhttp3.*
import okio.Buffer
import java.io.EOFException
import java.io.IOException
import java.nio.charset.Charset
import java.nio.charset.UnsupportedCharsetException
import java.util.*
import java.util.concurrent.TimeUnit

class HttpLogInterceptor(val tag: String = "") : Interceptor {


    @Throws(IOException::class)
    @Synchronized
    override fun intercept(chain: Interceptor.Chain): Response {
        val logList = ArrayList<String>()

        val request = chain.request()
        val requestBody = request.body
        logList.add("【${request.method}】 【${request.url}】")

        initHeaders(logList, request.headers)

        if (requestBody != null) {
            val sb = StringBuilder()
            if (requestBody is MultipartBody) {
                for (part in requestBody.parts) {

                    part.headers?.let {
                        for (i in 0 until it.size) {
                            sb.append("【%s = %s】\n", it.name(i), it.value(i))
                        }
                    }

                    val partBody = part.body.contentType()
                    if (partBody != null
                        && when (partBody.type.toLowerCase()) {
                            "video", "image", "file" -> true
                            else -> false
                        }
                    ) {
                        sb.append("*******************************************************************\n")
                        sb.append("***************这里是文件的数据，省略输出**************************\n")
                        sb.append("*******************************************************************\n\n")
                    } else {
                        sb.append(
                            String.format(
                                "【MultipartBody = %s】",
                                formatBodyToString(part.body)
                            )
                        )
                    }
                    sb.append("\n\n")
                }
            } else {
                sb.append(formatBodyToString(requestBody))
            }

            logList.add("【Request Body】: " + sb.toString())
        }
        logList.add(
            String.format(
                "***************** END 【%s】Request ************************************************\n\n",
                request.method
            )
        )

        val startNs = System.nanoTime()
        val response: Response
        try {
            response = chain.proceed(request)
        } catch (e: Exception) {
            logList.add("<-- HTTP FAILED: $e")
            KLog.httpLog(logList, tag)
            e.printStackTrace()
            throw e
        }

        val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)

        val responseBody = response.body
        val contentLength = responseBody!!.contentLength()
       if (response.request.url.toString().contains("upload/weyArticle/pdf")){
 //        下载PDF链接  url = http://wuyoudemo.gwmsystem.com:1212/upload/weyArticle/pdf/1538039027155.pdf
 // 将responseBody发送出去用于监听下载进度
            EventBus.getDefault().post(responseBody)
        }
        logList.add("【code = ${response.code}】,【url = ${response.request.url}】,【${tookMs}ms】")

        initHeaders(logList, response.headers)

        val source = responseBody.source()
        source.request(Long.MAX_VALUE) // Buffer the entire body.
        val buffer = source.buffer

        var charset: Charset? = UTF8
        val contentType = responseBody.contentType()
        if (contentType != null) {
            try {
                charset = contentType.charset(UTF8)
            } catch (e: UnsupportedCharsetException) {
                logList.add("Couldn't decode the response body; charset is likely malformed.")
                logList.add("<-- END HTTP")
                return response
            }

        }

        if (!isPlaintext(buffer)) {
            logList.add("<-- END HTTP (binary " + buffer.size + "-byte body omitted)")
            return response
        }
        if (contentLength != 0L) {
            logList.add("↓↓↓↓↓↓↓↓↓↓↓↓【Response Data】↓↓↓↓↓↓↓↓↓↓↓")
            logList.add(buffer.clone().readString(charset!!))
        }
        logList.add("<-- END HTTP (" + buffer.size + " -byte body)")
        KLog.httpLog(logList, tag)
        return response
    }

    private fun formatBodyToString(requestBody: RequestBody): String {
        var result = ""
        try {
            val buffer = Buffer()
            requestBody.writeTo(buffer)
            var charset: Charset? = UTF8
            val contentType = requestBody.contentType()
            if (contentType != null) {
                charset = contentType.charset(UTF8)
            }

            if (isPlaintext(buffer)) {
                result = buffer.readString(charset!!)
            }
        } catch (e: IOException) {
            e.printStackTrace()
            result = "解析错误"
        }

        return result
    }

    private fun initHeaders(logList: ArrayList<String>, headers: Headers) {
        for (i in 0 until headers.size) {
            val name = headers.name(i)
            logList.add(String.format("【%s = %s】", name, headers.value(i)))
        }
    }

    private fun bodyEncoded(headers: Headers): Boolean {
        val contentEncoding = headers.get("Content-Encoding")
        return contentEncoding != null && !contentEncoding.equals("identity", true)
    }

    companion object {
        val UTF8 = Charset.forName("UTF-8")

        /**
         * Returns true if the body in question probably contains human readable text. Uses a small sample
         * of code points to detect unicode control characters commonly used in binary file signatures.
         */
        internal fun isPlaintext(buffer: Buffer): Boolean {
            try {
                val prefix = Buffer()
                val byteCount = if (buffer.size < 64) buffer.size else 64
                buffer.copyTo(prefix, 0, byteCount)
                for (i in 0..15) {
                    if (prefix.exhausted()) {
                        break
                    }
                    val codePoint = prefix.readUtf8CodePoint()
                    if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
                        return false
                    }
                }
                return true
            } catch (e: EOFException) {
                return false // Truncated UTF-8 sequence.
            }

        }
    }


}

```
## 自定义ResponseBody

```
package com.beans.base.interceptors;

import com.beans.base.net.ProgressListener;

import java.io.IOException;

import okhttp3.MediaType;
import okhttp3.ResponseBody;
import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

/**
 * @Author yangtianfu
 * @CreateTime 2020/4/16 14:09
 * @Describe 自定义ResponseBody
 */
public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ProgressListener progressListener;
    private BufferedSource bufferedSource;
    private final String url;

    ProgressResponseBody(String url, ResponseBody responseBody, ProgressListener progressListener) {
        this.responseBody = responseBody;
        this.progressListener = progressListener;
        this.url = url;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(final Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                progressListener.update(url, totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}

```

## 下载进度拦截器

```
package com.beans.base.interceptors

import com.beans.base.net.ProgressListener
import okhttp3.Interceptor
import okhttp3.Response


/**
 * @Author yangtianfu
 * @CreateTime 2020/4/16 14:00
 * @Describe 下载进度拦截器
 */
class ProgressInterceptor constructor(progressListener: ProgressListener) :Interceptor{
    var progressListener:ProgressListener? = null
    init {
        this.progressListener = progressListener
    }
    companion object{

    }
    override fun intercept(chain: Interceptor.Chain): Response {
       var  originalResponse= chain.proceed(chain.request())
        return originalResponse.newBuilder()
            .body(
                ProgressResponseBody(
                    chain.request().url.toString(),
                    originalResponse.body,
                    this.progressListener
                )
            )
            .build()
    }
}
```

## 进度监听回调

```
/**
 * @Author yangtianfu
 * @CreateTime 2020/4/16 14:07
 * @Describe 进度监听回调
 */
interface ProgressListener {
    fun update(
        url: String?,
        bytesRead: Long,
        contentLength: Long,
        done: Boolean
    )
}
```


```
     var progressInterceptor = ProgressInterceptor(object : ProgressListener {
                override fun update(
                    url: String?,
                    bytesRead: Long,
                    contentLength: Long,
                    done: Boolean
                ) {

//                    logE("下载进度监听：$contentLength")
                }
            })
```











