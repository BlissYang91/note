## Dagger2注解说明

>1.@Inject
 依赖需求方，在需要依赖的地方使用这个注解。（你用它告诉Dagger这个 构造方法，成员变量或者函数方法需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。）@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖；

> 2.@Module
 依赖提供方，Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的 依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules)，
 @Module用于标注提供依赖的类。你可能会有点困惑，很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。

> 3.@Provide
提供依赖的具体实现方法，在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。提供对象实例的方法。
用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值；


>4.@Component
是依赖需求方和依赖提供方之间的桥梁，用于标注接口。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入

>5.@Qulifier
@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。----一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示；

>6.@Scope
 同样用于自定义注解，Dagger2可以通过自定义注解限定注解作用域。我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例

>7.@Singleton
当前提供的对象将是单例模式 ,一般配合@Provides一起出现,@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。

---

## @Inject和@Module的区别
> @Inject和@Module都可以提供依赖，如果我们在构造函数上通过标记@Inject提供依赖，又通过@Module提供依赖Dagger2选择具体规则如下：
 步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。
 步骤2：若存在提供依赖的方法，查看该方法是否存在参数。
    a：若存在参数，则按从步骤1开始依次初始化每个参数；
    b：若不存在，则直接初始化该类实例，完成一次依赖注入。
 步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。
    a：若存在参数，则从步骤1开始依次初始化每一个参数
    b：若不存在，则直接初始化该类实例，完成一次依赖注入。